---
description: 
globs: 
alwaysApply: true
---
Use curl to test the endpoint and check the response structure when you need changes in the front.

## ðŸ§­ General Guidelines

- Avoid code duplication. Always scan the `convision-api` and `convision-font` projects before creating new code.
- All code must follow best practices and clean architecture patterns.
- All information in the frontend must be presented in Spanish.
- Always apply your changes in the project â€” partial or local-only changes are not accepted.
- Backend always runs on port `8000` and frontend on port `4200`.

---

## âš™ï¸ Backend (Laravel)

- Always use **Laravel Form Request classes** to validate controller inputs. Do not write validations directly in controllers.
- Use `apiFilterable` to filter and order data consistently:
  - Add the trait to your model.
  - In controllers, use `$model->apiFilter($request)` instead of manual filtering.
- Create services or actions to isolate business logic from controllers.
- Use **Eloquent relationships** and eager loading to avoid N+1 query issues.
- All controller logic should be delegated to services or actions.
- Handle exceptions using custom exception classes or Laravel's centralized handler.
- Use Laravel policies or gates for authorization.
- Every new model must include its **migration**, **factory**, and **seeder**.

---

## ðŸŒ API Communication

- Always create services to isolate and reuse API communication logic.
- Never hardcode secrets or API endpoints â€” use environment variables.
- All API calls must be handled in `/services`, not directly in components.
- Use `axios` with interceptors to attach auth tokens and handle global errors.
- Add proper error handling and user feedback for all API calls.
- Always show loading states and disable repeated actions while waiting for responses.

---

## ðŸ§© Frontend (React)

- Use **functional components** with **React Hooks** only. Avoid class components.
- Always render tables using the centralized **DataTable** module.
- Maintain consistent structure using folders like `components/`, `pages/`, and `services/`.
- Use controlled components for forms and prefer custom hooks for reusable logic.
- Use `useCallback`, `useMemo`, and dependency arrays properly to avoid unnecessary re-renders.
- Use Tailwind CSS for styling instead of inline styles or separate CSS files.
- Max component size: **200 lines**. Break down logic into smaller components if needed.

---

## ðŸ§ª Testing

- All backend logic must be tested using PHPUnit (Feature or Unit tests).
- Use factories for test data â€” avoid relying on seeders.
- For frontend components, write basic tests using **React Testing Library**.
- Ensure consistency and reproducibility in test environments using `.env.testing`.

---

## ðŸ” Environment and Secrets

- Never commit `.env`, `.env.local`, or private keys.
- Keep `.env.example` up-to-date with all required environment variables.
- Use `.env.testing` for test environment overrides.

---


## ðŸ§ª Sample cURL for Backend Login Testing

bash
curl --location 'http://localhost:8000/api/v1/auth/login' \
--header 'Content-Type: application/json' \
--data-raw '{
  "email": "admin@convision.com",
  "password": "password"
}'

Backend application always are running in port 8000 and front in 4200.

When you need a backend token you could get using this curl
curl --location 'http://localhost:8000/api/v1/auth/login' \
--header 'Content-Type: application/json' \
--data-raw '{
    "email": "admin@convision.com",
    "password": "password"
}'

ApiFilterable: Siempre usar para filtrar y ordenar datos. En backend, aÃ±adir trait a modelos y usar ->apiFilter($request) en controladores. En frontend, enviar parÃ¡metros s_f (campos) y s_v (valores) como JSON, y usar DataTable para renderizar tablas de forma centralizada. Obligatorio para mantener consistencia en filtrado, bÃºsqueda y paginaciÃ³n.

Los request de los controladores deben ser validados usando Laravel request para evitar escribir el codigo de estas validacines dentro del controlador.

Instrucciones para obtener el descuento de un producto
Estructura de datos
Un producto (lente) tiene una propiedad has_discounts (booleano) que indica si tiene descuentos disponibles
Los descuentos tienen un campo discount_percentage que almacena el porcentaje de descuento
Cada descuento estÃ¡ asociado a un lens_id y opcionalmente a un patient_id
Flujo para obtener el descuento
Verificar si el producto tiene descuentos disponibles (lens.has_discounts === true)
Llamar al servicio discountService.getBestDiscount(lensId, patientId?) para obtener el mejor descuento disponible
Extraer el porcentaje de descuento con bestDiscount.discount_percentage
Calcular el precio con descuento usando discountService.calculateDiscountedPrice(originalPrice, discountPercentage)

# Laravel Form Request Validation Pattern

## Overview
This project follows a strict pattern for handling request validation using Laravel Form Requests instead of inline validation in controllers. This pattern ensures consistency, maintainability, and proper separation of concerns.

## Directory Structure
All Form Requests must be organized in the following structure:

app/Http/Requests/Api/V1/{ControllerName}/{ActionName}{ControllerName}Request.php


### Examples:
- `app/Http/Requests/Api/V1/Patient/StorePatientRequest.php`
- `app/Http/Requests/Api/V1/Patient/UpdatePatientRequest.php`
- `app/Http/Requests/Api/V1/Appointment/StoreAppointmentRequest.php`
- `app/Http/Requests/Api/V1/Prescription/StorePrescriptionRequest.php`

## Naming Convention
- **Store operations**: `Store{ControllerName}Request.php`
- **Update operations**: `Update{ControllerName}Request.php`

# MDC - PatrÃ³n de DiseÃ±o Laravel API Resources

## Instrucciones Obligatorias para Controladores API

### 1. Estructura de Recursos
**NUNCA usar `response()->json()` directamente en controladores API. SIEMPRE usar Laravel API Resources.**

#### OrganizaciÃ³n de Recursos por Carpetas
Los recursos deben organizarse en subcarpetas agrupadas por funcionalidad relacionada:

```
app/Http/Resources/V1/
â”œâ”€â”€ User/
â”‚   â”œâ”€â”€ UserResource.php
â”‚   â””â”€â”€ UserCollection.php
â”œâ”€â”€ Patient/
â”‚   â”œâ”€â”€ PatientResource.php
â”‚   â””â”€â”€ PatientCollection.php
â”œâ”€â”€ Lens/

```

### 2. Namespace y Estructura de Recursos

#### Resource Individual
```php
<?php

namespace App\Http\Resources\V1\[Categoria];

use Illuminate\Http\Request;
use Illuminate\Http\Resources\Json\JsonResource;

class [Modelo]Resource extends JsonResource
{
    public function toArray(Request $request): array
    {
        return [
            'id' => $this->id,
            'campo1' => $this->campo1,
            'campo2' => $this->campo2,
            'created_at' => $this->created_at,
            'updated_at' => $this->updated_at,
        ];
    }
}
```

#### Collection
```php
<?php

namespace App\Http\Resources\V1\[Categoria];

use Illuminate\Http\Request;
use Illuminate\Http\Resources\Json\ResourceCollection;

class [Modelo]Collection extends ResourceCollection
{
    public function toArray(Request $request): array
    {
        return parent::toArray($request);
    }
}
```

### 3. PatrÃ³n de Controladores API

#### Imports Obligatorios
```php
use App\Http\Resources\V1\[Categoria]\[Modelo]Resource;
use App\Http\Resources\V1\[Categoria]\[Modelo]Collection;
```

#### MÃ©todos EstÃ¡ndar

**Index (Listado con paginaciÃ³n)**
```php
public function index(Request $request)
{
    $query = [Modelo]::apiFilter($request);
    
    $perPage = $request->get('per_page', 15);
    $perPage = min(max(1, (int)$perPage), 100);
    
    $items = $query->paginate($perPage);
    
    return new [Modelo]Collection($items);
}
```

**Show (Mostrar individual)**
```php
public function show($id)
{
    $item = [Modelo]::findOrFail($id);
    return new [Modelo]Resource($item);
}
```

**Store (Crear)**
```php
public function store(Store[Modelo]Request $request)
{
    $validatedData = $request->validated();
    
    $item = [Modelo]::create($validatedData);
    
    return new [Modelo]Resource($item);
}
```

**Update (Actualizar)**
```php
public function update(Update[Modelo]Request $request, $id)
{
    $item = [Modelo]::findOrFail($id);
    $validatedData = $request->validated();
    
    $item->update($validatedData);
    
    return new [Modelo]Resource($item->fresh());
}
```

**Destroy (Eliminar)**
```php
public function destroy($id)
{
    $item = [Modelo]::findOrFail($id);
    $item->delete();
    
    return response()->json(null, 204);
}
```

### 4. Reglas de ApiFilterable

**OBLIGATORIO usar ApiFilterable en todos los listados:**
- En el modelo: aÃ±adir trait `ApiFilterable`
- En el controlador: usar `->apiFilter($request)` en queries
- En frontend: enviar parÃ¡metros `s_f` (campos) y `s_v` (valores) como JSON

### 5. ValidaciÃ³n con Request Classes

**NUNCA validar directamente en controladores. SIEMPRE usar Laravel Request classes:**

```php
// Crear: app/Http/Requests/Api/V1/[Categoria]/Store[Modelo]Request.php
// Actualizar: app/Http/Requests/Api/V1/[Categoria]/Update[Modelo]Request.php
```

### 6. Casos Especiales

#### Controladores que NO necesitan Resources
- Controladores de importaciÃ³n (retornan estado de acciÃ³n)
- Controladores de autenticaciÃ³n (pueden usar UserResource existente)
- Controladores de PDF (retornan archivos)
- Controladores de lookup/bÃºsqueda simple


#### PaginaciÃ³n Personalizada
```php
public function index(Request $request)
{
    $query = [Modelo]::with(['relacion1', 'relacion2'])
        ->apiFilter($request);
    
    $perPage = $request->get('per_page', 15);
    $perPage = min(max(1, (int)$perPage), 100);
    
    $items = $query->paginate($perPage);
    
    return new [Modelo]Collection($items);
}
```

### 7. Checklist de ImplementaciÃ³n

Al crear/refactorizar un controlador API:

- [ ] Â¿EstÃ¡ usando Laravel API Resources en lugar de `response()->json()`?
- [ ] Â¿Los recursos estÃ¡n organizados en subcarpetas por categorÃ­a?
- [ ] Â¿El namespace del resource es correcto (`App\Http\Resources\V1\[Categoria]`)?
- [ ] Â¿EstÃ¡ usando `apiFilter($request)` para filtrado?
- [ ] Â¿EstÃ¡ usando Request classes para validaciÃ³n?
- [ ] Â¿La paginaciÃ³n estÃ¡ limitada (mÃ¡ximo 100 items)?
- [ ] Â¿Los mÃ©todos destroy retornan 204 sin contenido?
- [ ] Â¿Los mÃ©todos store/update usan `validated()` data?

## IMPORTANTE
Este patrÃ³n es OBLIGATORIO para todos los controladores API nuevos y debe aplicarse al refactorizar controladores existentes. Mantiene consistencia, reutilizaciÃ³n y facilita el mantenimiento del cÃ³digo. 


